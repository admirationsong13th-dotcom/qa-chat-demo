<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>固定Q&Aチャット（デモ）</title>
  <style>
    :root { --bg:#0b1020; --panel:#101a33; --line:#223056; --text:#e9eefc; --muted:#a9b5d6; }
    body { margin:0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif; background:linear-gradient(180deg,#0b1020,#070a14); color:var(--text); }
    .wrap { max-width: 860px; margin: 0 auto; padding: 18px; }
    .card { background: rgba(16,26,51,.9); border:1px solid rgba(34,48,86,.9); border-radius: 16px; overflow:hidden; box-shadow: 0 10px 30px rgba(0,0,0,.35); }
    header { padding: 14px 16px; border-bottom:1px solid rgba(34,48,86,.9); display:flex; gap:10px; align-items:center; }
    header .dot { width:10px; height:10px; border-radius:999px; background:#5cff9d; box-shadow:0 0 16px rgba(92,255,157,.5); }
    header h1 { margin:0; font-size: 14px; font-weight: 700; letter-spacing:.02em; }
    header small { color:var(--muted); }
    #log { height: 62vh; min-height: 360px; padding: 14px; overflow:auto; background: rgba(7,10,20,.35); }
    .msg { display:flex; margin: 10px 0; }
    .msg.user { justify-content:flex-end; }
    .bubble { max-width: 78%; padding: 10px 12px; border-radius: 14px; line-height: 1.5; white-space: pre-wrap; word-break: break-word; }
    .user .bubble { background:#2c6cff; color:white; border-bottom-right-radius: 6px; }
    .bot .bubble { background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.08); border-bottom-left-radius: 6px; }
    .meta { margin-top:6px; font-size: 12px; color: var(--muted); }
    .chips { display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; }
    .chip { background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); color:var(--text); padding:6px 10px; border-radius: 999px; cursor:pointer; font-size: 12px; }
    .chip:hover { background: rgba(255,255,255,.10); }
    footer { border-top:1px solid rgba(34,48,86,.9); padding: 12px; display:flex; gap:10px; align-items:center; }
    input { flex:1; padding: 12px 12px; border-radius: 12px; border:1px solid rgba(255,255,255,.14); background: rgba(255,255,255,.06); color: var(--text); outline:none; }
    input::placeholder { color: rgba(233,238,252,.55); }
    button { padding: 12px 14px; border-radius: 12px; border:1px solid rgba(255,255,255,.14); background: rgba(255,255,255,.10); color: var(--text); cursor:pointer; font-weight: 700; }
    button:hover { background: rgba(255,255,255,.16); }
    .status { padding: 10px 14px; color: var(--muted); font-size: 12px; border-top:1px dashed rgba(34,48,86,.9); }
    code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <header>
        <div class="dot"></div>
        <div>
          <h1>固定Q&Aチャット（デモ） <small>／ qa.json を参照</small></h1>
          <small id="qaInfo">Q&A読み込み中…</small>
        </div>
      </header>

      <div id="log" aria-live="polite"></div>

      <footer>
        <input id="q" type="text" placeholder="質問を入力（例：営業時間は？）" autocomplete="off" />
        <button id="send">送信</button>
      </footer>

      <div class="status" id="status">
        使い方：<code>qa.json</code> に登録した質問に対して固定回答します（完全一致→部分一致の順）。
      </div>
    </div>
  </div>

  <script>
    // ====== 設定 ======
    const QA_JSON_PATH = "./qa.json"; // GitHub Pagesで同じ階層に置く想定

    // ====== 状態 ======
    let QA = [];

    // ====== ユーティリティ ======
    function normalize(s) {
      return (s ?? "")
        .toString()
        .trim()
        .toLowerCase()
        // 半角/全角スペース削除
        .replace(/\s+/g, "")
        .replace(/　+/g, "")
        // 末尾の?・？は無視したいことが多いので削除
        .replace(/[?？]+$/g, "")
        // よくある句読点や記号をざっくり除去（必要なら調整）
        .replace(/[。．.、,！!「」『』（）()［］\[\]【】]/g, "");
    }

    function addMessage(role, text, extraNode) {
      const log = document.getElementById("log");
      const row = document.createElement("div");
      row.className = "msg " + role;

      const bubble = document.createElement("div");
      bubble.className = "bubble";
      bubble.textContent = text;

      row.appendChild(bubble);
      log.appendChild(row);

      if (extraNode) {
        const wrap = document.createElement("div");
        wrap.style.marginTop = "6px";
        row.appendChild(wrap);
        wrap.appendChild(extraNode);
      }

      log.scrollTop = log.scrollHeight;
    }

    function makeChips(questions) {
      const box = document.createElement("div");
      box.className = "chips";
      questions.forEach(q => {
        const b = document.createElement("button");
        b.type = "button";
        b.className = "chip";
        b.textContent = q;
        b.onclick = () => {
          document.getElementById("q").value = q;
          document.getElementById("q").focus();
        };
        box.appendChild(b);
      });
      return box;
    }

    // ====== 検索ロジック（完全一致 → 部分一致） ======
    function findAnswer(userText) {
      const u = normalize(userText);
      if (!u) return { type: "empty" };

      // 1) 完全一致
      for (const item of QA) {
        if (normalize(item.q) === u) {
          return { type: "exact", item };
        }
      }

      // 2) 部分一致（候補をスコアリング）
      const scored = QA.map(item => {
        const nq = normalize(item.q);
        let score = 0;
        if (nq.includes(u)) score += 2;     // 質問文がユーザー入力を含む
        if (u.includes(nq)) score += 1;     // ユーザー入力が質問文を含む（短い質問に強い）
        // 文字数が近いほどちょい加点
        score += Math.max(0, 1 - Math.abs(nq.length - u.length) / 20);
        return { item, score };
      }).filter(x => x.score > 0);

      scored.sort((a,b) => b.score - a.score);

      if (scored.length) {
        const best = scored[0].item;
        const suggestions = scored.slice(0, 5).map(x => x.item.q);
        return { type: "partial", item: best, suggestions };
      }

      return { type: "none" };
    }

    // ====== メイン処理 ======
    async function loadQA() {
      try {
        const res = await fetch(QA_JSON_PATH, { cache: "no-store" });
        if (!res.ok) throw new Error("fetch failed: " + res.status);
        const data = await res.json();

        // 想定：[{q:"",a:""}...] 形式
        if (!Array.isArray(data)) throw new Error("qa.json is not an array");
        QA = data
          .filter(x => x && typeof x.q === "string" && typeof x.a === "string")
          .map(x => ({ q: x.q.trim(), a: x.a.trim() }));

        document.getElementById("qaInfo").textContent = `Q&A ${QA.length}件を読み込みました`;
        addMessage("bot", "こんにちは。固定Q&Aデモです。質問を入力してください。");
      } catch (e) {
        document.getElementById("qaInfo").textContent = "Q&Aの読み込みに失敗しました（qa.json を確認）";
        addMessage("bot",
          "qa.json の読み込みに失敗しました。\n" +
          "・同じ階層に qa.json があるか\n" +
          "・JSONの書式が正しいか（カンマや括弧）\n" +
          "を確認してください。"
        );
        console.error(e);
      }
    }

    function onSend() {
      const input = document.getElementById("q");
      const text = input.value;
      if (!text.trim()) return;

      addMessage("user", text);
      input.value = "";

      const r = findAnswer(text);

      if (r.type === "exact") {
        addMessage("bot", r.item.a);
        return;
      }

      if (r.type === "partial") {
        // ベスト回答を返しつつ、候補も出す
        const node = makeChips(r.suggestions);
        addMessage("bot", r.item.a + "\n\n（もしかしてこの質問？）", node);
        return;
      }

      if (r.type === "none") {
        // よく使う例：上位候補を出したいなら、ここでQAの一部を提示してもOK
        addMessage("bot", "該当するQ&Aが見つかりませんでした。質問文を少し変えてみてください。");
        return;
      }
    }

    // ====== 起動 ======
    document.getElementById("send").addEventListener("click", onSend);
    document.getElementById("q").addEventListener("keydown", (e) => {
      if (e.key === "Enter") onSend();
    });

    loadQA();
  </script>
</body>
</html>

<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>デモ_ベアジョン_Q&Aチャット</title>

  <style>
    :root{
      --accent:#00A0D0;
      --accent2:#0bb6ea;

      --bg:#f7fafc;
      --card:#ffffff;
      --text:#0f172a;
      --muted:#64748b;
      --line:rgba(15,23,42,.10);
      --shadow:0 18px 45px rgba(15,23,42,.10);
      --radius:18px;

      --bot:#f1f5f9;
      --user:#00A0D0;
      --userText:#ffffff;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
      color:var(--text);
      background:
        radial-gradient(900px 600px at 15% -10%, rgba(0,160,208,.14), transparent 55%),
        radial-gradient(900px 600px at 85% 0%, rgba(0,160,208,.08), transparent 55%),
        linear-gradient(180deg, #ffffff, var(--bg));
    }

    .wrap{ max-width: 980px; margin: 0 auto; padding: 18px; }
    .card{
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding: 14px 16px;
      border-bottom: 1px solid var(--line);
      background: linear-gradient(180deg, rgba(0,160,208,.06), rgba(255,255,255,0));
    }

    .brand{
      display:flex;
      align-items:center;
      gap:12px;
      min-width:0;
    }

    .logo{
      width: 140px;
      height: auto;
      display:block;
      filter: drop-shadow(0 6px 14px rgba(15,23,42,.10));
    }

    .titleWrap{ display:flex; flex-direction:column; gap:2px; min-width:0; }
    h1{
      margin:0;
      font-size: 14px;
      font-weight: 900;
      letter-spacing:.02em;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:6px;
      font-size: 12px;
      color: var(--muted);
      font-weight: 800;
    }
    .pill{
      display:inline-block;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(0,160,208,.25);
      background: rgba(0,160,208,.06);
      color: var(--text);
      font-weight: 900;
      font-size: 12px;
    }

    .actions{ display:flex; gap:8px; align-items:center; flex:0 0 auto; }
    .ghost{
      appearance:none;
      border: 1px solid var(--line);
      background: #fff;
      color: var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 800;
      cursor:pointer;
    }
    .ghost:hover{ background: rgba(15,23,42,.03); }

    #log{
      height: 66vh;
      min-height: 390px;
      padding: 16px;
      overflow:auto;
      background: linear-gradient(180deg, rgba(241,245,249,.45), rgba(255,255,255,0));
    }

    .msg{ display:flex; margin: 10px 0; gap:8px; }
    .msg.user{ justify-content:flex-end; }

    .bubble{
      max-width: 78%;
      padding: 10px 12px;
      border-radius: 14px;
      line-height: 1.6;
      white-space: pre-wrap;
      word-break: break-word;
      border: 1px solid transparent;
      transform: translateY(2px);
      animation: pop .16s ease-out forwards;
    }
    @keyframes pop { to { transform: translateY(0);} }

    .bot .bubble{
      background: var(--bot);
      border-color: rgba(15,23,42,.06);
      border-bottom-left-radius: 6px;
      color: var(--text);
    }
    .user .bubble{
      background: var(--user);
      color: var(--userText);
      border-bottom-right-radius: 6px;
      box-shadow: 0 10px 22px rgba(0,160,208,.22);
    }

    .typing{
      display:inline-flex; gap:6px; align-items:center;
    }
    .typing i{
      width:6px; height:6px; border-radius:999px;
      background: rgba(15,23,42,.45);
      animation: blink 1s infinite ease-in-out;
      display:inline-block;
    }
    .typing i:nth-child(2){ animation-delay:.15s; }
    .typing i:nth-child(3){ animation-delay:.30s; }
    @keyframes blink{
      0%, 80%, 100%{ opacity:.25; transform: translateY(0); }
      40%{ opacity:1; transform: translateY(-2px); }
    }

    .chips{ display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; }
    .chip{
      border: 1px solid rgba(0,160,208,.28);
      background: rgba(0,160,208,.06);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 999px;
      cursor:pointer;
      font-size: 12px;
      line-height: 1.15;
      font-weight: 900;
      text-align:left;
      transition: transform .05s ease-out;
    }
    .chip:hover{ background: rgba(0,160,208,.10); }
    .chip:active{ transform: translateY(1px); }

    .chipPrimary{
      border-color: rgba(0,160,208,.35);
      background: linear-gradient(180deg, rgba(11,182,234,.14), rgba(0,160,208,.08));
    }

    footer{
      border-top: 1px solid var(--line);
      padding: 12px;
      display:flex;
      gap:10px;
      align-items:center;
      background: #fff;
    }

    .input{
      flex:1;
      display:flex;
      align-items:center;
      gap:10px;
      background: rgba(241,245,249,.75);
      border:1px solid rgba(15,23,42,.10);
      border-radius: 14px;
      padding: 10px 12px;
    }

    input{
      flex:1;
      border:0;
      outline:none;
      background: transparent;
      color: var(--text);
      font-size: 14px;
      padding: 2px 2px;
    }
    input::placeholder{ color: rgba(100,116,139,.85); }

    .send{
      appearance:none;
      border: 1px solid rgba(0,160,208,.25);
      background: linear-gradient(180deg, var(--accent2), var(--accent));
      color: white;
      border-radius: 14px;
      padding: 12px 16px;
      cursor:pointer;
      font-weight: 900;
      letter-spacing:.02em;
      box-shadow: 0 12px 26px rgba(0,160,208,.22);
    }
    .send:hover{ filter: brightness(1.02); }
    .send:disabled{ opacity:.55; cursor:not-allowed; box-shadow:none; }

    .ghost:focus-visible, .send:focus-visible, input:focus-visible, .chip:focus-visible{
      outline: 3px solid rgba(0,160,208,.25);
      outline-offset: 2px;
      border-radius: 12px;
    }

    .tiny{
      font-size: 12px;
      color: var(--muted);
      font-weight: 800;
    }

    @media (max-width: 560px){
      .logo{ width: 110px; }
      #log{ height: 64vh; }
      .bubble{ max-width: 86%; }
      .actions{ gap:6px; }
      .ghost{ padding: 10px 10px; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card">
      <header>
        <div class="brand">
          <img class="logo" src="./logo.png" alt="BEAR JOHN" onerror="this.style.display='none'">
          <div class="titleWrap">
            <h1>デモ_ベアジョン_Q&Aチャット</h1>
            <div class="badge">
              現在のジャンル：
              <span class="pill" id="genrePill">未選択</span>
            </div>
          </div>
        </div>
        <div class="actions">
          <button class="ghost" id="changeGenre" type="button">ジャンル変更</button>
          <button class="ghost" id="clear" type="button">会話をクリア</button>
        </div>
      </header>

      <div id="log" aria-live="polite"></div>

      <footer>
        <div class="input">
          <input id="q" type="text" placeholder="ジャンルを選んでから質問してください" autocomplete="off" />
        </div>
        <button class="send" id="send" type="button" disabled>送信</button>
      </footer>
    </div>
  </div>

  <!-- Fuse.js（あいまい検索） -->
  <script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2"></script>

  <script>
    const QA_JSON_PATH = "./qa.json";

    // “よくある質問”は「遊技台・オススメ」系の例として固定表示
    const PRESET_QUESTIONS = [
      "ジャグラーシリーズについて教えて",
      "オススメ機種は？",
      "新台のデータを出して",
      "今週出てない台をランキング形式で出して"
    ];

    // ====== ジャンル定義 ======
    const GENRES = [
      { id: "store", label: "営業時間や設備などに関するお問い合わせ" },
      { id: "machines", label: "遊技台やオススメ機種などに関するお問い合わせ" },
      { id: "requests", label: "店舗への要望など" }
    ];

    // ジャンル自動分類キーワード（qa.jsonは編集不要）
    // ※必要に応じて増やしてください（精度が上がります）
    const GENRE_KEYWORDS = {
      store: [
        "営業時間","開店","閉店","何時","営業","住所","場所","行き方","アクセス","最寄","電話","番号",
        "駐車場","駐輪","トイレ","喫煙","分煙","休憩","設備","Wi-Fi","wifi","充電","ロッカー","景品","交換","レート"
      ],
      machines: [
        "台","機種","おすすめ","オススメ","推し","新台","新機種","導入","入替","最新","データ","ランキング",
        "ジャグラー","juggler","アイム","マイ","ゴーゴー","gogo","ファンキー","ハッピー","北斗","からくり","モンキー"
      ],
      requests: [
        "要望","改善","お願い","クレーム","苦情","意見","希望","不満","対応","接客","店員","清掃","汚い","暑い","寒い","音","臭い","並び","ルール"
      ]
    };

    // ====== 状態 ======
    let QA = [];
    let currentGenre = null; // "store" | "machines" | "requests" | null

    // Fuse（全体＋ジャンル別）
    let fuses = { all: null, store: null, machines: null, requests: null };

    const logEl = document.getElementById("log");
    const inputEl = document.getElementById("q");
    const sendBtn = document.getElementById("send");
    const genrePill = document.getElementById("genrePill");

    // タイピング中キャンセル用（会話クリア等で中断できる）
    let typingToken = 0;

    // ====== 表記ゆれ吸収（必要なら増やしてOK） ======
    function replaceVariants(s){
      return (s ?? "")
        .replace(/オススメ/g, "おすすめ")
        .replace(/お薦め/g, "おすすめ")
        .replace(/ｵｽｽﾒ/g, "おすすめ")
        .replace(/JUGGLER/ig, "ジャグラー")
        .replace(/ｼﾞｬｸﾞﾗｰ/g, "ジャグラー");
    }

    function normalize(s) {
      return replaceVariants(s)
        .toString()
        .trim()
        .toLowerCase()
        .replace(/\s+/g, "")
        .replace(/　+/g, "")
        .replace(/[?？]+$/g, "")
        .replace(/[。．.、,！!「」『』（）()［］\[\]【】]/g, "");
    }

    // ====== UI ======
    function addMessage(role, text) {
      const row = document.createElement("div");
      row.className = "msg " + role;

      const bubble = document.createElement("div");
      bubble.className = "bubble";
      bubble.textContent = text ?? "";

      row.appendChild(bubble);
      logEl.appendChild(row);

      logEl.scrollTop = logEl.scrollHeight;
      return { row, bubble };
    }

    function addTypingDots() {
      const row = document.createElement("div");
      row.className = "msg bot";
      const bubble = document.createElement("div");
      bubble.className = "bubble";
      const t = document.createElement("span");
      t.className = "typing";
      t.innerHTML = "<i></i><i></i><i></i>";
      bubble.appendChild(t);
      row.appendChild(bubble);
      logEl.appendChild(row);
      logEl.scrollTop = logEl.scrollHeight;
      return row;
    }

    function makeChips(labels, onClick, primary=false) {
      const box = document.createElement("div");
      box.className = "chips";
      labels.forEach((label, idx) => {
        const b = document.createElement("button");
        b.type = "button";
        b.className = "chip" + (primary ? " chipPrimary" : "");
        b.textContent = label;
        b.onclick = () => onClick(label, idx);
        box.appendChild(b);
      });
      return box;
    }

    function setReady(ready) {
      // ジャンル未選択なら常に送信不可
      const ok = ready && !!currentGenre;
      sendBtn.disabled = !ok;
      inputEl.disabled = !ready;
      inputEl.placeholder = currentGenre
        ? "質問を入力してください"
        : "まずジャンルを選んでください";
    }

    // ====== タイピング ======
    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    async function typeText(bubble, fullText, speedMs = 18, tokenAtStart = 0) {
      let skip = false;
      bubble.addEventListener("click", () => { skip = true; }, { once: true });

      bubble.textContent = "";
      for (let i = 0; i < fullText.length; i++) {
        if (typingToken !== tokenAtStart) return;
        if (skip) { bubble.textContent = fullText; break; }
        bubble.textContent += fullText[i];
        logEl.scrollTop = logEl.scrollHeight;

        if (fullText[i] === "\n") {
          await sleep(Math.max(6, Math.floor(speedMs / 2)));
        } else {
          await sleep(speedMs);
        }
      }
    }

    async function botTypeMessage(text, extraNode) {
      // ready=false（送信不可）にして、タイピング重なりを防ぐ
      const prevGenre = currentGenre; // 表示更新のため
      sendBtn.disabled = true;
      inputEl.disabled = true;

      const token = ++typingToken;
      const { bubble } = addMessage("bot", "");

      await typeText(bubble, text, 18, token);
      if (typingToken !== token) return;

      if (extraNode) bubble.appendChild(extraNode);

      inputEl.disabled = false;
      setReady(true);
      // 変なタイミングでジャンルが変わっても整合性保つ
      if (prevGenre !== currentGenre) setGenreUI();
      inputEl.focus();
    }

    // ====== Fuseインデックス作成 ======
    function makeFuse(list){
      return new Fuse(list ?? [], {
        keys: ["q"],
        includeScore: true,
        threshold: 0.35,      // 0.25〜0.45で調整
        ignoreLocation: true
      });
    }

    function classifyByKeywords(item){
      const text = normalize(item.q + " " + item.a);
      const hits = {
        store: GENRE_KEYWORDS.store.some(k => text.includes(normalize(k))),
        machines: GENRE_KEYWORDS.machines.some(k => text.includes(normalize(k))),
        requests: GENRE_KEYWORDS.requests.some(k => text.includes(normalize(k)))
      };

      // 複数ヒットする場合は優先度で決める（用途に合わせて調整可）
      // 例：要望っぽい語があるなら requests を優先
      if (hits.requests) return "requests";
      if (hits.machines) return "machines";
      if (hits.store) return "store";

      // どれにも当たらないものは store に寄せる（無難）
      return "store";
    }

    function buildFuses(){
      if (!window.Fuse) {
        fuses = { all:null, store:null, machines:null, requests:null };
        return;
      }
      fuses.all = makeFuse(QA);

      const groups = { store: [], machines: [], requests: [] };
      for (const item of QA) {
        const g = classifyByKeywords(item);
        groups[g].push(item);
      }

      fuses.store = makeFuse(groups.store);
      fuses.machines = makeFuse(groups.machines);
      fuses.requests = makeFuse(groups.requests);
    }

    // ====== ジャンル選択 ======
    function setGenreUI(){
      if (!currentGenre){
        genrePill.textContent = "未選択";
        return;
      }
      const g = GENRES.find(x => x.id === currentGenre);
      genrePill.textContent = g ? g.label : currentGenre;
    }

    async function promptGenreSelection(){
      currentGenre = null;
      setGenreUI();
      setReady(true); // inputは使えるが送信は不可

      const labels = GENRES.map(g => g.label);
      const chips = makeChips(labels, async (_label, idx) => {
        currentGenre = GENRES[idx].id;
        setGenreUI();
        // 選択後の案内（デモ用）
        await botTypeMessage("ジャンルを選びました。質問を入力してください。");

        // “よくある質問”は machinesジャンルのデモ例として表示
        if (currentGenre === "machines") {
          await botTypeMessage("よくある質問：", makeChips(PRESET_QUESTIONS, (q) => {
            inputEl.value = q;
            inputEl.focus();
          }, true));
        }

        setReady(true);
      }, true);

      await botTypeMessage("まずジャンルを選んでください：", chips);
    }

    // ====== 検索 ======
    function findAnswer(userText) {
      const raw = replaceVariants(userText);
      const u = normalize(raw);
      if (!u) return { type: "empty" };

      // 1) 完全一致（ジャンル内）
      const list =
        currentGenre === "store" ? (fuses.store? fuses.store._docs : QA) :
        currentGenre === "machines" ? (fuses.machines? fuses.machines._docs : QA) :
        currentGenre === "requests" ? (fuses.requests? fuses.requests._docs : QA) :
        QA;

      for (const item of list) {
        if (normalize(item.q) === u) return { type: "exact", item };
      }

      // 2) ジャンル内Fuse
      const fuseToUse =
        currentGenre === "store" ? fuses.store :
        currentGenre === "machines" ? fuses.machines :
        currentGenre === "requests" ? fuses.requests :
        fuses.all;

      if (fuseToUse && typeof fuseToUse.search === "function") {
        const results = fuseToUse.search(raw).slice(0, 6);
        if (results.length) {
          return {
            type: "partial",
            item: results[0].item,
            suggestions: results.map(r => r.item.q)
          };
        }
      }

      // 3) 全体Fuseへフォールバック（取りこぼし防止）
      if (fuses.all && fuseToUse !== fuses.all) {
        const results2 = fuses.all.search(raw).slice(0, 6);
        if (results2.length) {
          return {
            type: "partial",
            item: results2[0].item,
            suggestions: results2.map(r => r.item.q)
          };
        }
      }

      return { type: "none" };
    }

    // ====== 初期化 ======
    async function loadQA() {
      setReady(false);
      const dots = addTypingDots();

      try {
        const res = await fetch(QA_JSON_PATH, { cache: "no-store" });
        if (!res.ok) throw new Error("fetch failed: " + res.status);

        const data = await res.json();
        if (!Array.isArray(data)) throw new Error("qa.json is not an array");

        QA = data
          .filter(x => x && typeof x.q === "string" && typeof x.a === "string")
          .map(x => ({ q: x.q.trim(), a: x.a.trim() }));

        buildFuses();
        dots.remove();

        await botTypeMessage("こんにちは。質問を入力してください");
        await promptGenreSelection();

        setReady(true);
        inputEl.focus();

      } catch (e) {
        dots.remove();
        await botTypeMessage(
          "Q&Aの読み込みに失敗しました。\n" +
          "・qa.json が同じ階層にあるか\n" +
          "・JSONの書式（カンマ/括弧）が正しいか\n" +
          "を確認してください。"
        );
        console.error(e);
        setReady(false);
      }
    }

    // ====== 送信処理 ======
    async function onSend() {
      const text = inputEl.value;
      if (!text || !text.trim() || sendBtn.disabled) return;

      // ジャンル未選択なら、質問前に選ばせる
      if (!currentGenre) {
        inputEl.value = "";
        await promptGenreSelection();
        return;
      }

      addMessage("user", text);
      inputEl.value = "";

      const dots = addTypingDots();
      await sleep(220);
      dots.remove();

      const r = findAnswer(text);

      if (r.type === "exact") {
        await botTypeMessage(r.item.a);
        return;
      }

      if (r.type === "partial") {
        await botTypeMessage(r.item.a + "\n\n（もしかして…）",
          makeChips(r.suggestions, (q) => {
            inputEl.value = q;
            inputEl.focus();
          })
        );
        return;
      }

      await botTypeMessage(
        "該当するQ&Aが見つかりませんでした。\n" +
        "・言い方を変える\n" +
        "・ジャンルを変更する\n" +
        "のどちらかを試してください。"
      );
    }

    // ====== ボタン ======
    sendBtn.addEventListener("click", onSend);
    inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") onSend();
    });

    document.getElementById("clear").addEventListener("click", async () => {
      typingToken++; // タイピング中断
      logEl.innerHTML = "";
      await botTypeMessage("会話をクリアしました。");
      await promptGenreSelection();
    });

    document.getElementById("changeGenre").addEventListener("click", async () => {
      await promptGenreSelection();
    });

    loadQA();
  </script>
</body>
</html>
